Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

cd меняет рабочую папку шелла, данная команда всегда встроенная  
если бы она была внешней, то не смогла бы менять параметры окружающей среды текущего сеанса шелла

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

опция -c или --count дает тот же эффект, что и '| wc -l', т.е. подсчитывает количество найденных строк 

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

systemd с pid 1

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?


    имеем две сессии:  
    vagrant@vagrant:~$ who  
    vagrant  pts/0        2021-11-20 15:15 (10.0.2.2)  
    vagrant  pts/1        2021-11-20 15:43 (10.0.2.2)  
    vagrant@vagrant:~$ ls  
    123.txt  history  temp  terraform  
    vagrant@vagrant:~$ ls blahblah  (вывод ошибки будет в текущем терминале)  
    ls: cannot access 'blahblah': No such file or directory  
    vagrant@vagrant:~$ ls blahblah 2> /dev/pts/1  
    вывод ошибки последней команды будет отображен в соседнем терминале:  
    vagrant@vagrant:~$ ls: cannot access 'blahblah': No such file or directory

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.


    vagrant@vagrant:~$ ls  
    123.txt  history  temp  terraform  
    vagrant@vagrant:~$ cat 123.txt  
    test message  
    vagrant@vagrant:~$ cat <123.txt > 1234.txt  
    vagrant@vagrant:~$ cat 1234.txt  
    test message  
    vagrant@vagrant:~$


6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

cat /proc/cpuinfo | grep sse  
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 pcid
sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase avx2 invpcid rdseed clflushopt md_clear flush_l1d  

делаем вывод, что максимальный набор инструкций sse это **sse4_2**

12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

tty выдает имя файла терминала, подключенного к стандартному вводу
команда ssh localhost 'tty' запускает новую ssh сессию и выполняет команду tty вместо логин шелла  
поскольку логин шелл не запускается, то и файл терминала к стандартному вводу не создается, поэтому и выдается сообщение от команды tty, что not a tty  
для решения проблемы нужно принудительно задать создание псевдотерминала при ssh подключении опцией -t  
например ssh -t localhost 'tty'


13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

для начала нужно установить параметр /proc/sys/kernel/yama/ptrace_scope в 0 (расширяет возможности дебага при использовании ptrace системы)
причем сделать это можно например таким образом (см. ответ на вопрос 14)
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
(напрямую sudo echo 0 > /proc/sys/kernel/yama/ptrace_scope выдает permission denied по той же причине, что и вопрос 14)
после этого выполняем reptyr id_процесса в новом screen для переноса

14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Tee выполняет чтение стандартного потока ввода и записывает его в стандартный поток вывода или файлы.  
Поэтому выполнение sudo tee дает права на запись текущего потоко из echo в файл, доступный только руту.

